<!DOCTYPE html>
<html lang="en">

<head>
    <title>OpenCV JavaScript</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            justify-content: center;
            padding-left: 5vw;
        }
    </style>
</head>

<body>
    <h1>Input Video</h1>
    <video id="video" width="300" height="200" autoplay muted></video>
    <h1>Output Video</h1>
    <canvas id="canvasOutput" width="300" height="200"></canvas>

    <script defer src="https://docs.opencv.org/master/opencv.js"></script>
    <script defer src="videotest.js"></script>
    <script defer>
        class SidePoleDetector {
            constructor(videoElement, canvasOutput) {
                this.videoElement = videoElement;
                this.canvasOutput = canvasOutput;
                this.srcImage = new cv.Mat();
                this.dstImage = new cv.Mat();
                this.cap = new cv.VideoCapture(this.videoElement);
                this.initOpenCV();
            }

            initOpenCV() {
                cv['onRuntimeInitialized'] = () => {
                    this.startVideo();
                    this.processVideoAndDetectPoles();
                };
            }

            startVideo() {
                this.videoElement.src = '08_SidePolesDetection.mp4';
                this.videoElement.play();
            }

            processVideoAndDetectPoles() {
                const FPS = 30;
                const processFrame = () => {
                    let begin = Date.now();
                    this.cap.read(this.srcImage);

                    if (this.srcImage.empty()) {
                        return;
                    }

                    this.dstImage.delete();
                    this.dstImage = new cv.Mat(this.srcImage.rows, this.srcImage.cols, cv.CV_8UC4);

                    this.detectPoles();

                    cv.imshow(this.canvasOutput, this.dstImage);

                    let delay = 1000 / FPS - (Date.now() - begin);
                    setTimeout(processFrame, delay);
                };

                processFrame();
            }

            detectPoles() {
                let hsv = new cv.Mat();
                let mask = new cv.Mat();
                let blurred = new cv.Mat();
                let edges = new cv.Mat();
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();

                cv.cvtColor(this.srcImage, hsv, cv.COLOR_RGBA2RGB);
                cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
                let lowerWhite = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 0, 168, 255]);
                let upperWhite = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [172, 111, 255, 255]);

                cv.inRange(hsv, lowerWhite, upperWhite, mask);
                cv.GaussianBlur(mask, blurred, new cv.Size(5, 5), 1.5, 1.5);
                cv.Canny(blurred, edges, 75, 150, 3, false);

                cv.findContours(
                    edges,
                    contours,
                    hierarchy,
                    cv.RETR_EXTERNAL,
                    cv.CHAIN_APPROX_SIMPLE
                );

                const minContourArea = 500;
                const aspectRatioThreshold = 0.2;
                const borderMargin = 10;

                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    let rect = cv.boundingRect(cnt);
                    let aspectRatio = rect.width / rect.height;

                    if (
                        area < minContourArea ||
                        aspectRatio < aspectRatioThreshold ||
                        rect.x < borderMargin ||
                        rect.y < borderMargin ||
                        rect.x + rect.width > this.srcImage.cols - borderMargin ||
                        rect.y + rect.height > this.srcImage.rows - borderMargin ||
                        this.isRoadMarking(cnt)
                    ) {
                        continue;
                    }

                    let color = new cv.Scalar(255, 0, 0);
                    cv.rectangle(
                        this.dstImage,
                        new cv.Point(rect.x, rect.y),
                        new cv.Point(rect.x + rect.width, rect.y + rect.height),
                        color,
                        2
                    );
                    console.log(`Detected a pole with aspectRatio: ${aspectRatio}, area: ${area}, width: ${rect.width}, height: ${rect.height}`);
                }

                hsv.delete();
                lowerWhite.delete();
                upperWhite.delete();
                mask.delete();
                blurred.delete();
                edges.delete();
                contours.delete();
                hierarchy.delete();
            }

            isRoadMarking(contour) {
                let rect = cv.boundingRect(contour);
                let aspectRatio = rect.width / rect.height;

                return (
                    aspectRatio > 5 &&
                    rect.y > this.srcImage.rows * 0.7
                );
            }
        }

        const videoElement = document.getElementById('video');
        const canvasOutput = document.getElementById('canvasOutput');
        const sidePoleDetector = new SidePoleDetector(videoElement, canvasOutput);
    </script>
</body>

</html>
